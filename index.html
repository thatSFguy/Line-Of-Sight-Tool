<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>RF Line-of-Sight Tool (910 MHz)</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        :root {
            --bg: #f9f9fb;
            --text: #333;
            --border: #ddd;
            --primary: #007bff;
            --danger: #dc3545;
            --success: #28a745;
            --warning: #ffc107;
            --dark-bg: #2c3e50;
            --dark-text: #ecf0f1;
        }

        [data-theme="dark"] {
            --bg: #2c3e50;
            --text: #ecf0f1;
            --border: #444;
            --primary: #3498db;
        }

        [data-theme="dark"] .notice {
            background: #d39e00;
            color: #fff;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 20px;
            background: var(--bg);
            color: var(--text);
            transition: background 0.3s, color 0.3s;
        }

        h1, h2 { color: var(--primary); margin-bottom: 10px; }

        .notice {
            background: var(--warning);
            color: #212529;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-size: 14px;
        }

        table {
            border-collapse: collapse;
            width: 100%;
            margin-top: 15px;
            background: white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        [data-theme="dark"] table { background: #34495e; }

        th, td {
            border: 1px solid var(--border);
            padding: 10px;
            text-align: left;
        }

        th {
            background-color: #f2f2f2;
            font-weight: 600;
        }

        [data-theme="dark"] th { background-color: #3a546e; }

        tr:hover { background-color: #f5f5f5; }
        [data-theme="dark"] tr:hover { background-color: #3a546e; }

        .error { color: var(--danger); margin: 10px 0; font-weight: 500; }
        .success { color: var(--success); margin: 10px 0; }

        .form-group {
            margin: 12px 0;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .form-group label {
            width: 220px;
            font-weight: 500;
        }

        .form-group input[type="file"],
        .form-group select,
        .form-group input[type="number"] {
            padding: 8px;
            border: 1px solid var(--border);
            border-radius: 4px;
            font-size: 14px;
        }

        .form-group input[type="radio"] {
            margin-right: 6px;
        }

        button {
            margin: 10px 0;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            background: var(--primary);
            color: white;
            transition: 0.2s;
        }

        button:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        .sample-link {
            font-size: 14px;
            color: var(--primary);
            text-decoration: underline;
        }

        #map {
            height: 400px;
            width: 100%;
            margin-top: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
        }

        .theme-toggle {
            position: fixed;
            top: 15px;
            right: 15px;
            background: var(--primary);
            color: white;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .chart-container {
            margin: 20px 0;
            padding: 15px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        [data-theme="dark"] .chart-container {
            background: #34495e;
        }
    </style>
</head>
<body>

    <button class="theme-toggle" onclick="toggleTheme()"></button>

    <h1>
        RF Line-of-Sight Tool (910 MHz) 
        <small style="font-size: 0.55em; color: #666;">
            <a href="nodemgr.html" target="NodeMgr" style="color: inherit; text-decoration: underline;">Node Manager</a>
        </small>
    </h1>

    <div class="notice">
        Note: Your data is stored in your browser's localStorage. Download your CSV from Node Manager before clearing cache.
    </div>

    <div class="form-group">
        <label>Data Source:</label>
        <input type="radio" name="dataSource" id="sourceCSV" value="csv" checked> CSV File
        <input type="radio" name="dataSource" id="sourceGroup" value="group"> Group from Node Manager
    </div>

    <div class="form-group" id="csvInput">
        <label>Upload CSV File:</label>
        <input type="file" id="csvFile" accept=".csv">
        <br>
        <a href="https://raw.githubusercontent.com/thatSFguy/Line-Of-Sight-Tool/main/RF_locations_sample.csv" 
           download="RF_locations_sample.csv" class="sample-link">Download Sample CSV</a>
    </div>

    <div class="form-group" id="groupInput" style="display: none;">
        <label>Select Group:</label>
        <select id="groupSelect">
            <option value="">Select a group</option>
        </select>
    </div>

    <div class="form-group">
        <label>Default antenna height (m):</label>
        <input type="number" id="defaultHeight" value="4" step="0.1">
    </div>

    <div class="form-group">
        <label>Diffraction loss threshold for 'Clear' LOS (dB):</label>
        <input type="number" id="losThreshold" value="6" step="0.1">
    </div>

    <button onclick="processData()">Process</button>

    <div id="results"></div>
    <div id="map"></div>

    <script>
        // === Theme Toggle ===
        const themeButton = document.querySelector('.theme-toggle');
        function toggleTheme() {
            const current = document.body.getAttribute('data-theme') || 'light';
            const newTheme = current === 'dark' ? 'light' : 'dark';
            document.body.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            themeButton.innerHTML = newTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
        }

        // Load theme
        let savedTheme = localStorage.getItem('theme');
        if (!savedTheme && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            savedTheme = 'dark';
        }
        if (savedTheme) {
            document.body.setAttribute('data-theme', savedTheme);
        }
        themeButton.innerHTML = (document.body.getAttribute('data-theme') || 'light') === 'dark' ? 'Sun' : 'Moon';

        // === Rest of your original script (unchanged logic) ===
        const FREQ_MHZ = 910;
        const LAMBDA = 300 / FREQ_MHZ;
        const EARTH_RADIUS = 6371000;
        const EFFECTIVE_RADIUS_FACTOR = 4 / 3;
        const EFFECTIVE_RADIUS = EARTH_RADIUS * EFFECTIVE_RADIUS_FACTOR;
        const HPROF_STEP = 100;
        const KM_TO_MILES = 0.621371;

        const TILE_CACHE = new Map();
        const BASE_TILE_URL = 'https://raw.githubusercontent.com/thatSFguy/Line-Of-Sight-Tool/main/tiles/';

        let map = null;

        function populateGroupDropdown() {
            const groupSelect = document.getElementById('groupSelect');
            groupSelect.innerHTML = '<option value="">Select a group</option>';
            const groups = JSON.parse(localStorage.getItem('groups')) || [];
            groups.forEach(group => {
                const option = document.createElement('option');
                option.value = group.name;
                option.textContent = group.name;
                groupSelect.appendChild(option);
            });
        }

        function toggleInputVisibility(source) {
            const csvInput = document.getElementById('csvInput');
            const groupInput = document.getElementById('groupInput');
            if (source === 'group') {
                csvInput.style.display = 'none';
                groupInput.style.display = 'block';
                populateGroupDropdown();
            } else {
                csvInput.style.display = 'block';
                groupInput.style.display = 'none';
            }
        }

        function restoreDataSource() {
            const savedSource = localStorage.getItem('dataSource') || 'csv';
            document.getElementById('sourceCSV').checked = savedSource === 'csv';
            document.getElementById('sourceGroup').checked = savedSource === 'group';
            toggleInputVisibility(savedSource);
        }

        document.getElementById('sourceCSV').addEventListener('change', () => {
            localStorage.setItem('dataSource', 'csv');
            toggleInputVisibility('csv');
        });
        document.getElementById('sourceGroup').addEventListener('change', () => {
            localStorage.setItem('dataSource', 'group');
            toggleInputVisibility('group');
        });

        document.getElementById('groupSelect').addEventListener('focus', populateGroupDropdown);

        function validateCSV(lines) {
            if (lines.length < 2) return "CSV must have at least two rows (Site A + one Site B)";
            const headers = lines[0].map(h => String(h).trim());
            const expected = ['Location Name', 'Latitude', 'Longitude', 'Height', 'Notes'];
            if (!headers.every((h, i) => h === expected[i])) {
                return "CSV headers must be: Location Name,Latitude,Longitude,Height,Notes";
            }
            const validRows = [];
            for (let i = 1; i < lines.length; i++) {
                const row = lines[i].map(v => String(v).trim().replace(/^"(.*)"$/, '$1'));
                if (row.length < 3 || !row[0] || isNaN(parseFloat(row[1])) || isNaN(parseFloat(row[2]))) {
                    continue;
                }
                if (row.length > 3 && row[3] && isNaN(parseFloat(row[3]))) {
                    return `Invalid Height in row ${i + 1}: ${row[3]}`;
                }
                validRows.push(row);
            }
            if (validRows.length < 1) return "No valid data rows after Site A";
            return { validRows: validRows.map(row => ({
                'Location Name': row[0],
                'Latitude': parseFloat(row[1]),
                'Longitude': parseFloat(row[2]),
                'Height': row[3] ? parseFloat(row[3]) : null,
                'Notes': row[4] || ''
            })) };
        }

        function groupToCSV(groupName) {
            const nodes = JSON.parse(localStorage.getItem('nodes')) || [];
            const groups = JSON.parse(localStorage.getItem('groups')) || [];
            const group = groups.find(g => g.name === groupName);
            if (!group) return null;
            const primaryNode = nodes.find(node => node.name === group.name);
            const includedNodes = nodes.filter(node => group.nodes.includes(node.name));
            const groupNodes = primaryNode ? [primaryNode, ...includedNodes] : includedNodes;
            if (groupNodes.length < 2) return null;
            const headers = ['Location Name', 'Latitude', 'Longitude', 'Height', 'Notes'];
            const rows = groupNodes.map(node => [
                String(node.name),
                String(node.latitude),
                String(node.longitude),
                String(node.height || ''),
                String(node.notes || '')
            ]);
            return [headers, ...rows];
        }

        function getTileName(lat, lon) {
            const latFloor = Math.floor(lat);
            const lonFloor = Math.floor(lon);
            const latStr = lat >= 0 ? 'N' + latFloor : 'S' + (-latFloor);
            const lonStr = lon >= 0 ? 'E' + ('00' + lonFloor).slice(-3) : 'W' + ('00' + (-lonFloor)).slice(-3);
            return latStr + lonStr + '.hgt.zip';
        }

        async function loadTile(tileName) {
            if (TILE_CACHE.has(tileName)) return TILE_CACHE.get(tileName);
            try {
                const response = await fetch(BASE_TILE_URL + tileName);
                if (!response.ok) throw new Error('Tile not found');
                const buffer = await response.arrayBuffer();
                const zip = await JSZip.loadAsync(buffer);
                const hgtFile = Object.values(zip.files)[0];
                const hgtBuffer = await hgtFile.async('arraybuffer');
                TILE_CACHE.set(tileName, hgtBuffer);
                return hgtBuffer;
            } catch (e) {
                console.error('Error loading tile:', e);
                return null;
            }
        }

        async function getElevation(lat, lon) {
            const tileName = getTileName(lat, lon);
            const buffer = await loadTile(tileName);
            if (!buffer) return 0;
            const view = new DataView(buffer);
            const latFrac = lat - Math.floor(lat);
            const lonFrac = lon - Math.floor(lon);
            const row = Math.floor((1 - latFrac) * 1200);
            const col = Math.floor(lonFrac * 1200);
            const index = (row * 1201 + col) * 2;
            let elev = view.getInt16(index, false);
            if (elev === -32768) elev = 0;
            return elev;
        }

        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371000;
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        function getIntermediatePoint(lat1, lon1, lat2, lon2, fraction) {
            const d = haversineDistance(lat1, lon1, lat2, lon2) / EARTH_RADIUS;
            const a = Math.sin((1 - fraction) * d) / Math.sin(d);
            const b = Math.sin(fraction * d) / Math.sin(d);
            const x = a * Math.cos(lat1 * Math.PI/180) * Math.cos(lon1 * Math.PI/180) + b * Math.cos(lat2 * Math.PI/180) * Math.cos(lon2 * Math.PI/180);
            const y = a * Math.cos(lat1 * Math.PI/180) * Math.sin(lon1 * Math.PI/180) + b * Math.cos(lat2 * Math.PI/180) * Math.sin(lon2 * Math.PI/180);
            const z = a * Math.sin(lat1 * Math.PI/180) + b * Math.sin(lat2 * Math.PI/180);
            const lat = Math.atan2(z, Math.sqrt(x*x + y*y)) * 180 / Math.PI;
            const lon = Math.atan2(y, x) * 180 / Math.PI;
            return {lat, lon};
        }

        async function getHeightProfile(latA, lonA, latB, lonB, step) {
            const totalDist = haversineDistance(latA, lonA, latB, lonB);
            const numSteps = Math.ceil(totalDist / step) + 1;
            const distances = [];
            const heights = [];
            let currentDist = 0;
            for (let i = 0; i < numSteps; i++) {
                const fraction = i / (numSteps - 1);
                const point = getIntermediatePoint(latA, lonA, latB, lonB, fraction);
                const height = await getElevation(point.lat, point.lon);
                heights.push(height);
                distances.push((currentDist / 1000 * KM_TO_MILES).toFixed(1));
                currentDist += totalDist / (numSteps - 1);
            }
            return {distances, heights, totalDist: totalDist / 1000 * KM_TO_MILES};
        }

        function knifeEdgeDiffractionLoss(v) {
            if (v <= -0.78) return 0;
            return 6.9 + 20 * Math.log10(Math.sqrt((v - 0.1)**2 + 1) + (v - 0.1));
        }

        function freeSpaceLoss(d_miles, freq_mhz) {
            const d_km = d_miles / KM_TO_MILES;
            return 32.45 + 20 * Math.log10(d_km) + 20 * Math.log10(freq_mhz);
        }

        async function processPair(nameA, latA, lonA, hA, nameB, latB, lonB, hB, notesB, losThreshold) {
            const profile = await getHeightProfile(latA, lonA, latB, lonB, HPROF_STEP);
            const distances = profile.distances;
            const heights = profile.heights;
            const totalDist = profile.totalDist;
            heights[0] += hA;
            heights[heights.length - 1] += hB;

            const distances_m = distances.map(d => d / KM_TO_MILES * 1000);
            const curvature_adjust = distances_m.map(d => (d ** 2) / (2 * EFFECTIVE_RADIUS));

            const los_line = [];
            for (let i = 0; i < heights.length; i++) {
                los_line.push(heights[0] + (heights[heights.length - 1] - heights[0]) * (distances[i] / totalDist));
            }

            let maxV = -Infinity;
            let maxIndex = -1;
            for (let i = 1; i < heights.length - 1; i++) {
                const adjustedTerrain = heights[i] - curvature_adjust[i];
                const adjustedLos = los_line[i] - curvature_adjust[i];
                const obstruction = adjustedTerrain - adjustedLos;
                if (obstruction > maxV) {
                    maxV = obstruction;
                    maxIndex = i;
                }
            }

            let diffractionLoss = 0;
            if (maxIndex > -1 && maxV > 0) {
                const d1 = distances_m[maxIndex];
                const d2 = distances_m[distances_m.length - 1] - d1;
                const h = maxV;
                const nu = h * Math.sqrt((d1 + d2) / (LAMBDA * d1 * d2));
                diffractionLoss = knifeEdgeDiffractionLoss(nu);
            }

            const fsLoss = freeSpaceLoss(totalDist, FREQ_MHZ);
            const totalLoss = fsLoss + diffractionLoss;
            const isLos = diffractionLoss < losThreshold ? 'Clear' : 'Obstructed';

            const canvasId = 'chart_' + nameB.replace(/\s/g, '_');
            const div = document.createElement('div');
            div.className = 'chart-container';
            div.innerHTML = `<h3>Path Profile: ${nameA} to ${nameB}</h3><canvas id="${canvasId}"></canvas>`;
            document.getElementById('results').appendChild(div);
            
            const ctx = document.getElementById(canvasId).getContext('2d');
            const isDark = document.body.getAttribute('data-theme') === 'dark';
            const terrainColor = isDark ? '#ecf0f1' : '#2c3e50';      // light in dark, dark in light
            const losColor     = isDark ? '#e74c3c' : '#e74c3c';      // red stays red
            const fillColor    = isDark ? 'rgba(236,240,241,0.15)' : 'rgba(44,62,80,0.1)';
            
            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: distances,
                    datasets: [{
                        label: 'Terrain Profile (Curvature Adjusted)',
                        data: heights.map((h, i) => h - curvature_adjust[i]),
                        borderColor: terrainColor,
                        backgroundColor: fillColor,
                        fill: true,
                        tension: 0.1
                    }, {
                        label: 'LOS Line',
                        data: los_line.map((l, i) => l - curvature_adjust[i]),
                        borderColor: losColor,
                        borderDash: [8, 4],
                        fill: false
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: { position: 'top' }
                    },
                    scales: {
                        x: { title: { display: true, text: 'Distance [miles]' } },
                        y: { title: { display: true, text: 'Height [m]' } }
                    }
                }
            });



            return { siteB: nameB, status: isLos, diffLoss: diffractionLoss.toFixed(2), fsLoss: fsLoss.toFixed(2), totalLoss: totalLoss.toFixed(2), latB, lonB, notesB };
        }

        async function processData() {
            const source = document.querySelector('input[name="dataSource"]:checked').value;
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = '<p>Loading terrain data and calculating paths...</p>';

            let lines;
            if (source === 'csv') {
                const file = document.getElementById('csvFile').files[0];
                if (!file) {
                    resultsDiv.innerHTML = '<p class="error">Please select a CSV file.</p>';
                    return;
                }
                const text = await file.text();
                lines = text.split('\n').map(l => l.trim().split(','));
            } else {
                const groupName = document.getElementById('groupSelect').value;
                if (!groupName) {
                    resultsDiv.innerHTML = '<p class="error">Please select a group.</p>';
                    return;
                }
                lines = groupToCSV(groupName);
                if (!lines || lines.length < 2) {
                    resultsDiv.innerHTML = '<p class="error">Selected group is invalid or has fewer than two nodes.</p>';
                    return;
                }
            }

            const validation = validateCSV(lines);
            if (typeof validation === 'string') {
                resultsDiv.innerHTML = `<p class="error">Error: ${validation}</p>`;
                return;
            }

            const data = validation.validRows;
            const defaultHeight = parseFloat(document.getElementById('defaultHeight').value);
            const losThreshold = parseFloat(document.getElementById('losThreshold').value);

            const locA = data[0];
            const nameA = locA['Location Name'];
            const latA = locA['Latitude'];
            const lonA = locA['Longitude'];
            const hA = locA['Height'] || defaultHeight;
            const notesA = locA['Notes'];

            resultsDiv.innerHTML = '';
            if (map) map.remove();
            const mapDiv = document.getElementById('map');
            mapDiv.innerHTML = '';
            map = L.map('map').setView([latA, lonA], 7);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; OpenStreetMap contributors'
            }).addTo(map);

            const table = document.createElement('table');
            table.innerHTML = `<tr><th>Site B</th><th>LOS Status</th><th>Diffraction Loss (dB)</th><th>Free-Space Loss (dB)</th><th>Total Loss (dB)</th><th>Notes</th></tr>`;
            const results = [];

            for (let i = 1; i < data.length; i++) {
                const locB = data[i];
                const nameB = locB['Location Name'];
                const latB = locB['Latitude'];
                const lonB = locB['Longitude'];
                const hB = locB['Height'] || defaultHeight;
                const notesB = locB['Notes'];
                const result = await processPair(nameA, latA, lonA, hA, nameB, latB, lonB, hB, notesB, losThreshold);
                results.push(result);
            }

            L.marker([latA, lonA], {
                icon: L.icon({ iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-blue.png', iconSize: [25, 41], iconAnchor: [12, 41] })
            }).addTo(map).bindPopup(`${nameA}${notesA ? '<br>Notes: ' + notesA : ''}`);

            results.forEach(r => {
                L.marker([r.latB, r.lonB], {
                    icon: L.icon({ iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-green.png', iconSize: [25, 41], iconAnchor: [12, 41] })
                }).addTo(map).bindPopup(`${r.siteB}${r.notesB ? '<br>Notes: ' + r.notesB : ''}`);
                L.polyline([[latA, lonA], [r.latB, r.lonB]], { 
                    color: r.status === 'Clear' ? '#3498db' : '#e74c3c', 
                    weight: 3,
                    opacity: 0.8
                }).addTo(map);
            });

            const bounds = [[latA, lonA], ...results.map(r => [r.latB, r.lonB])];
            map.fitBounds(bounds, { padding: [50, 50] });

            results.forEach(r => {
                const tr = document.createElement('tr');
                tr.innerHTML = `<td>${r.siteB}</td><td><strong>${r.status}</strong></td><td>${r.diffLoss}</td><td>${r.fsLoss}</td><td>${r.totalLoss}</td><td>${r.notesB}</td>`;
                table.appendChild(tr);
            });

            const div = document.createElement('div');
            div.innerHTML = `<h2>LOS Results (from Site A: ${nameA})</h2>`;
            div.appendChild(table);
            document.getElementById('results').appendChild(div);
        }

        // Initial setup
        restoreDataSource();
    </script>
</body>
</html>
